#!/usr/bin/env python

"""
Take the mash distance to compute a dendrogram using ete3.
"""

__author__ = "Timo Dijkstra BSc."
__version__ = "1.0"
__title__ = "Take the mash distance to compute a dendrogram using ete3."
__author_email__ = "T.Dijkstra@naktuinbouw.nl"
__date__ = "07-02-2021"


import re
import argparse
import pandas as pd
from pathlib import Path
from colorama import Fore
from typing import TextIO, Tuple, Dict, List
from skbio.tree import nj
from skbio import DistanceMatrix
from ete3 import TreeNode, TreeStyle, NodeStyle
from utils.utils import is_valid_directory, is_valid_file, is_valid_path

OUTPUT_FILE = "Mash_tree_ete3.png"


def parse_args():
    """ Parse command line arguments """

    parser = argparse.ArgumentParser(description='Create a hierarchical tree plot based on output of mash triangle.')
    parser.add_argument('-md', '--mashdistance', type=lambda x: is_valid_path(parser, x), required=True,
                        help='Path to the .mashdist file.')
    parser.add_argument('-l', '--labels', type=lambda x: is_valid_file(parser, x), required=True,
                        help='Path to the Labels.csv file generated by mash_dendrogram.py giving annotations by '
                             'the distances. The order has to be similar to the order of rows/columns of the '
                             '.mashdist file generated by mash_dendrogram.py')
    parser.add_argument('-li', '--labels_ingroup', type=lambda x: is_valid_file(parser, x), required=True,
                        help='Path to the Labels_ingroup.csv file generated by mash_dendrogram.py.')
    parser.add_argument('-o', '--output', type=lambda x: is_valid_directory(parser, x), required=False, default="./",
                        help='Output directory of the Mash tree.')

    return parser.parse_args()


def mashdist_to_dataframe(mashdistance: str) -> pd.DataFrame:
    """
    Function to read the mash distance file and computes a dataframe with distances in triangular format.
    :param mashdistance: Path to the .mashdist file.
    :return: Dataframe with the distances in triangular format.
    """
    dist_matrix = []
    with open(mashdistance) as file:
        for line in file:
            dist_matrix.append(line.split())
    length_last_row = int(dist_matrix[0][0])
    dist_matrix = [list(map(float, row[1:])) for row in dist_matrix]
    n_additional_length = [length_last_row - len(row) for row in dist_matrix[1:]]
    additional_length = [[0] * element for element in n_additional_length]
    dist_matrix = [row + additional_length[i] for i, row in enumerate(dist_matrix[1:])]
    dist_matrix_df = pd.DataFrame(dist_matrix)
    return dist_matrix_df


def get_full_distance_dataframe(distance_dataframe_triangular: pd.DataFrame) -> pd.DataFrame:
    """
    Currently, the dataframe is triangular. This function converts the triangular dataframe to a full distance
    dataframe.
    :param distance_dataframe_triangular: Dataframe with the distances in triangular format.
    :return: Full dataframe with the distances.
    """
    for index_row, row in distance_dataframe_triangular.iterrows():
        nrows_ncols_df = distance_dataframe_triangular.shape[0]
        for column in range(nrows_ncols_df - 1, index_row, -1):
            distance_dataframe_triangular.iloc[index_row, column] = distance_dataframe_triangular.iloc[column, index_row]
    return distance_dataframe_triangular


def convert_mashdist_to_newick(mashdistance: str, labels: TextIO) -> Tuple[str, Dict[str, str]]:
    """
    Compute a newick tree from the .mashdist file generated by mash_dendrogram.py.
    :param mashdistance: Path to the .mashdist file.
    :param labels: Opened csv file storing the labels of the tree.
    :return: String storing a dendrogram in newick format and a dictionary linking the genome names to ids.
    """
    labels = labels.readline().split(",")
    label_dict = {str(index): label for index, label in enumerate(labels)}
    distance_dataframe_triangular = mashdist_to_dataframe(mashdistance)
    distance_matrix = get_full_distance_dataframe(distance_dataframe_triangular)
    distance_matrix = DistanceMatrix(distance_matrix, map(str, label_dict.keys()))
    newick_str = str(nj(distance_matrix))
    return newick_str, label_dict


def style_dendrogram(newick: str, label_dict: Dict[str, str], ingroup_labels: List[str], output):
    """
    Make a dendrogram using ete3 and highlight ingroup genomes.
    :param newick: String storing a dendrogram in newick format.
    :param label_dict: A dictionary linking the genome names to ids.
    :param ingroup_labels: List storing genome names of the ingroup.
    :param output: Output directory of the Mash tree.
    """
    tree = TreeNode(newick, format=1)
    # Change node names and adjust colors for ingroup.
    for node in tree.traverse():
        node.name = label_dict.get(node.name)
        # Define this if statement to prevent getting the error: "NoneType is not iterable."
        if node.name is not None:
            search_node_name = re.sub("[^0-9a-zA-Z]+", "", node.name)
            if any([re.sub("[^0-9a-zA-Z]+", "", name) in search_node_name for name in ingroup_labels]):
                ingroup_node = node
                ingroup_node.set_style(NodeStyle())
                ingroup_node.img_style["bgcolor"] = "#20d60f"

    tree.set_style(NodeStyle())
    tree_style = TreeStyle()
    tree_style.show_leaf_name = True
    tree_style.show_branch_length = True
    tree_style.aligned_foot = True
    tree.render(file_name=str(output / OUTPUT_FILE), tree_style=tree_style)


def main():
    args = parse_args()
    newick_str, label_dict = convert_mashdist_to_newick(args.mashdistance, args.labels)
    style_dendrogram(newick_str, label_dict, args.labels_ingroup.readline().split(","), Path(args.output))
    print(F"{Fore.GREEN}FINISHED")


if __name__ == '__main__':
    main()
