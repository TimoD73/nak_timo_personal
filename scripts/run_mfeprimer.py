#!/usr/bin/env python

"""
Run MFEprimer-3.2.3 recursively.
"""

__author__ = "Timo Dijkstra BSc."
__version__ = "1.0"
__title__ = "Run MFEprimer-3.2.3 recursively."
__author_email__ = "T.Dijkstra@naktuinbouw.nl"
__date__ = "30-09-2021"


import argparse
import subprocess
import pandas as pd
from pathlib import Path
from colorama import Fore
from typing import Dict, List
from collections import defaultdict

from utils.utils import is_valid_path, is_valid_directory

GENOME_EXTENSIONS = ["*.fna", "*.fasta", "*.fa"]
NAME_DATAFRAME_DIRECTORY = "MFEprimer_dataframe_results"
TMP_PRIMER_FA_NAME = "Primer_sequences.fa"
TMP_GENOME_FA_NAME = "Primer_genome.fa"
TRACEBACK_DICTIONARY = "Traceback_dataframe.tsv"


def convert_to_bool(arg: str) -> bool:
    """
    Function to convert the string given by the commandline to a boolean.
    :param arg: Either the string "True" or "False".
    :return: A boolean if the input was valid.
    """
    if arg == "True":
        return True
    elif arg == "False":
        return False
    else:
        print(F"{Fore.RED}No valid input. The options are either [True] or [False]")
        quit()


def parse_args() -> argparse:
    """ Parse command line arguments """
    parser = argparse.ArgumentParser(description="Script to run MFEprimer. Either analyze effectors from T3Enc "
                                                 "or analyze effectors from an in-house sequenced genome.")
    parser.add_argument("-i", "--input", type=lambda x: is_valid_path(parser, x),
                        required=True, metavar="FILE", help="Table  generated by Primer_Design_script.py."
                                                            "with all the primers needed for quality control.")
    parser.add_argument("-g", "--genome", type=lambda x: is_valid_directory(parser, x), required=True, metavar="DIR",
                        help="A directory containing genomes of interest to determine primer specificity (.fna/.fasta.")
    parser.add_argument("-c", "--control", required=False, default="", type=lambda x: is_valid_path(parser, x),
                        help="Path to a fasta file containing a control assay.")
    parser.add_argument('-cg', '--control_genomes', required=False, nargs="+", default="",
                        help="List of genome paths that corresponds to the control assay. This parameter must be"
                             "given in combination with the control parameter.")
    parser.add_argument("-ds", "--database_save", type=lambda x: is_valid_directory(parser, x), metavar="DIR",
                        required=False, default="./",
                        help="Directory for long term storage of (indexed) genomes.")
    parser.add_argument("-pp", "--python_prepare", type=lambda x: is_valid_path(parser, x),
                        required=True, metavar="FILE", help="Path to Prepare_input_files.py.")
    parser.add_argument("-ma", "--mfe_analysis", type=lambda x: is_valid_path(parser, x),
                        required=True, metavar="FILE", help="Path to Analyze_MFEprimer_output.py")
    parser.add_argument("-mfe", "--mfeprimer", type=lambda x: is_valid_path(parser, x),
                        required=True, metavar="FILE", help="Path to the mfeprimer-3.2.3-linux-amd64")
    parser.add_argument("-t", "--threads", type=int, required=False, default=1,
                        help="Number of threads to run MFEprimer.")
    parser.add_argument("-of", "--output_fa", type=str, required=False,
                        default="./", help='Output directory of the intermediate primer .fa files.')
    parser.add_argument("-oj", "--output_json", type=lambda x: is_valid_directory(parser, x), required=False,
                        default="./", help='Output directory of the mfeprimer-3.2.3 output.')
    parser.add_argument("-sj", "--save_json", type=lambda x: convert_to_bool(x), required=False, default=False,
                        choices=[True, False], help="Saving the direct output from MFEprimer can take a lot of "
                                                    "memory when the genome size is in the hundreds. By default, the "
                                                    "you can save the output.")
    parser.add_argument("--group", choices=["Ingroup", "Outgroup"], required=False, default="", type=str,
                        help="Group of the genome(s). [--group Ingroup] or [--group Outgroup]. "
                             "Providing a group is not required.")

    args = parser.parse_args()
    return args


def adjust_df_results_name(group: str) -> str:
    """
    If the group name is given, add the group name to the directory name.
    :param group: Group of the genome(s). Either an ingroup or an outgroup.
    :return: (Adjusted) group name.
    """
    if group:
        group += "_" + NAME_DATAFRAME_DIRECTORY
    return group


def move_single_genome(args: argparse, genome: Path, genome_identifier: str) -> str:
    """
    This function will copy the genome to the long term storage directory.
    :param args: An object of attributes generated from the console input.
    :param genome: Path to the genome of interest.
    :param genome_identifier: String that uniquely identifies the genome.
    :return: A string that will be used for naming files and corresponds to the genome name.
    """
    subprocess.run(F"cp {genome} {Path(args.database_save) / genome_identifier}.fa", shell=True)
    return genome_identifier


def calculate_rows(table_path: Path) -> int:
    """
    Determine the number of rows in a dataframe.
    :param table_path: Path to the input dataframe.
    :return: Number of rows.
    """
    dataframe = pd.read_csv(filepath_or_buffer=table_path, sep="\t")
    return len(dataframe.index)


def prepare_input_single_genome(args: argparse, row: int):
    """
    Generate the primer input for MFEprimer.
    :param args: An object of attributes generated from the console input.
    :param row: The row number of the primer dataframe.
    """
    subprocess.run(F"python3 {args.python_prepare} -i {args.input} -n {row} -o {args.output_fa}",
                   shell=True, capture_output=True)


def primers_exists(output_path: Path) -> bool:
    """
    Determine if the file exists.
    :param output_path: Path to the output directory.
    :return: True if the file exists.
    """
    output_path = output_path / TMP_PRIMER_FA_NAME
    return output_path.is_file()


def index_genome(args: argparse, genome_identifier: str) -> Path:
    """
    Execute the mfeprimer index function. The function checks if the genome is already indexed to save running time.
    :param args: An object of attributes generated from the console input.
    :param genome_identifier: String that uniquely identifies the genome.
    :return: The path to the indexed genome.
    """
    supposed_indexed_genome_path = Path(args.database_save) / genome_identifier
    supposed_indexed_genome_path.with_suffix(".fa.fai")
    if not supposed_indexed_genome_path.is_file():
        subprocess.run(F"{args.mfeprimer} index -i {Path(args.database_save) / genome_identifier}.fa -c {args.threads}",
                       shell=True)
    return supposed_indexed_genome_path


def mfeprimer_output_path(output_json: Path, row: int, genome_identifier: str) -> Path:
    """
    Create a unique MFEprimer output filename.
    :param output_json: Output path to the directory specific for this genome of interest.
    :param row: The row number of the primer dataframe.
    :param genome_identifier: String that uniquely identifies the genome.
    :return: Path, including a unique filename, for the MFEprimer output files.
    """
    unique_primer_identifier = str(row) + "_" + genome_identifier
    mfe_primer_output = output_json / unique_primer_identifier
    mfe_primer_output.with_suffix(".mfe")
    return mfe_primer_output


def run_mfeprimer(args: argparse, indexed_genome_file: Path, mfe_primer_output: Path):
    """
    Run MFEprimer and generate .json files as output. Give a log message if the analysis is done.
    :param args: An object of attributes generated from the console input.
    :param indexed_genome_file: The path to the indexed genome.
    :param mfe_primer_output: Path, including a unique filename, for the MFEprimer output files.
    """
    subprocess.run(F"{args.mfeprimer} -j -i {Path(args.output_fa) / TMP_PRIMER_FA_NAME} "
                   F"-d {indexed_genome_file}.fa -o {mfe_primer_output} -c {args.threads}", shell=True)

    print(F"{Fore.BLUE}DONE: {open(Path(args.output_fa) / TMP_PRIMER_FA_NAME).readline().strip('>')}")


def save_traceback_df_single_genome(dictionary: Dict[str, list], output: Path):
    """
    Function that saves the traceback dictionary as .tsv file for a newly sequenced genome.
    It stores the dataframe in the same directory as the MFEprimer output.
    :param dictionary: A dictionary containing two columns: File and Effector_protein.
    :param output: Output directory of the mfeprimer-3.2.3 output.
    """
    traceback_df = pd.DataFrame.from_dict(dictionary)
    # noinspection PyTypeChecker
    traceback_df.to_csv(output / TRACEBACK_DICTIONARY, sep="\t")


def run_single_genome_mfeprimer_analysis(args: argparse, genome: Path, output_json: Path):
    """
    Master function for running MFEprimer for newly sequenced genomes. MFEprimer runs for every available primer set.
    :param args: An object of attributes generated from the console input.
    :param genome: Path to the genome of interest.
    :param output_json: Output path to the directory specific for this genome of interest.
    """
    traceback_dictionary = defaultdict(list)
    genome_identifier = genome.name.strip(genome.suffix)
    move_single_genome(args, genome, genome_identifier)
    length_of_primer_table = calculate_rows(Path(args.input))
    for i in range(1, length_of_primer_table + 1):
        prepare_input_single_genome(args, i)
        if primers_exists(Path(args.output_fa)):
            # Add control primers if given to primer file.
            if args.control and isinstance(args.control_genomes, list):
                with open(args.control) as fasta:
                    control_primers = fasta.read()
                with open(Path(args.output_fa) / TMP_PRIMER_FA_NAME, "a") as fasta:
                    fasta.write("\n" + control_primers)

            indexed_genome_file = index_genome(args, genome_identifier)
            mfe_primer_output = mfeprimer_output_path(output_json, i, genome_identifier)

            run_mfeprimer(args, indexed_genome_file, mfe_primer_output)

            traceback_dictionary["File"].append(str(mfe_primer_output).split("/")[-1])

            with open(Path(args.output_fa) / TMP_PRIMER_FA_NAME) as f:
                traceback_dictionary["Effector_protein"].append(f.readline().split("|")[-1].strip("\n"))

            subprocess.run(F"rm {Path(args.output_fa) / TMP_PRIMER_FA_NAME}", shell=True)

    save_traceback_df_single_genome(traceback_dictionary, output_json)


def run_mfe_primer_analysis(mfe_analysis: str, genome: Path, json_directory: Path, save_directory: bool,
                            path_output: Path, control: str = "", control_genomes: List[str] = ""):
    """
    Run the script to analyze the results generated from MFEprimer-3.2.3. The script will make a clear dataframe
    from the generated .json files. If the user does not
    :param mfe_analysis: Path to Analyze_MFEprimer_output.py.
    :param genome: Path to the genome of interest.
    :param json_directory: Output path to the directory specific for this genome of interest.
    :param save_directory: Boolean that tells whether the direct MFEprimer output need to be saved.
    :param path_output: Output path to the directory for storing the dataframes generated by the .json files.
    :param control: Path to a fasta file containing a control assay.
    :param control_genomes: List of genome paths for the control assay.
    """
    if control and isinstance(control_genomes, list):
        subprocess.run(F"python3 {mfe_analysis} -i {json_directory} -g {genome} -o {path_output} "
                       F"--control {control} --control_genomes {control_genomes}", shell=True)
    else:
        subprocess.run(F"python3 {mfe_analysis} -i {json_directory} -g {genome} -o {path_output}", shell=True)
    if not save_directory:
        subprocess.run(F"rm -r {json_directory}", shell=True)
    print(F"{Fore.GREEN}DONE: MFEprimer analysis for {path_output.name.strip(path_output.suffix)}")


def run_mfe_primer_multiple_genomes(args: argparse):
    """
    Run MFEprimer recursively for every genome in the directory. Make also a directory with clear dataframes.
    Force to overwrite existing directories.
    :param args: An object of attributes generated from the console input.
    """

    dataframe_result_directory = args.output_json / adjust_df_results_name(args.group)
    if not Path.is_dir(dataframe_result_directory):
        Path.mkdir(dataframe_result_directory)

    genome_paths = [file for ext in GENOME_EXTENSIONS for file in args.genome.rglob(ext)]
    for genome in genome_paths:
        genome_name = args.output_json / genome.name.strip(genome.suffix)
        output_json = args.output_json / genome_name
        Path.mkdir(output_json, exist_ok=True)

        run_single_genome_mfeprimer_analysis(args, genome, output_json)
        run_mfe_primer_analysis(args.mfe_analysis, genome, output_json, args.save_json,
                                Path(dataframe_result_directory / genome.name.strip(genome.suffix)).with_suffix(".tsv"),
                                control=args.control, control_genomes=args.control_genomes)


def main():
    args = parse_args()
    args.genome = Path(args.genome)
    args.output_json = Path(args.output_json)
    run_mfe_primer_multiple_genomes(args)

    print(F"{Fore.GREEN}FINISHED")


if __name__ == '__main__':
    main()
