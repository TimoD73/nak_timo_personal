#!/usr/bin/env python

"""
Assays do not have always have a 100% specificity for the outgroup. However, we might be able to design a specific
multiplex assay if we can find a combination that gives two hits for the ingroup and 1 or 0 hits for the outgroup.
"""

__author__ = "Timo Dijkstra BSc."
__version__ = "1.0"
__title__ = "Search for multiplex assay combinations"
__author_email__ = "T.Dijkstra@naktuinbouw.nl"
__date__ = "02-02-2022"

import json
import argparse
import pandas as pd
from pathlib import Path
from colorama import Fore
from typing import Dict, Any
from itertools import combinations
from collections import defaultdict
from utils.utils import is_valid_directory, deal_with_large_tables

INPUT_EXTENSION = ".tsv"
OPTIMAL_SPECIFICITY = 100
MAXIMUM_AMPLICONS_MULTIPLEX = 2
HTML_FILE_NAME = "Effector_primers_multiplex.html"
TSV_FILE_NAME = "Effector_primers_multiplex.tsv"


def parse_args() -> argparse:
    """ Parse command line arguments """
    parser = argparse.ArgumentParser(description="Assays do not have always have a 100% specificity for the outgroup. "
                                                 "However, we might be able to design a specific multiplex assay if we "
                                                 "can find a combination that gives two hits for the ingroup and 1 or "
                                                 "0 hits for the outgroup.")
    parser.add_argument("-i", "--input_dir", required=True, type=lambda x: is_valid_directory(parser, x),
                        help="Path to the directory containing Effector_primers_general_results.tsv and "
                             "Effector_primers_Nested_MFEprimer_results_assay_n_ingroup.tsv.")
    parser.add_argument('-l', '--labels', type=Path, required=False, default="",
                        help='Path to the Labels.json file generated by mash_dendrogram.py giving annotations by '
                             'the distances.')
    parser.add_argument("-o", "--output", required=False, default=Path("./"), type=Path,
                        help="Relative path of output directory.")

    args = parser.parse_args()
    return args


def get_necessary_dataframes(input_directory: Path) -> Dict[str, pd.DataFrame]:
    """
    Extract the general results and the nested MFEprimer results from the directory generated by
    Combine_pipeline_results.py.
    :param input_directory: Path to the output directory of Combine_pipeline_results.py.
    :return: Dictionary of dataframes as input for the script among which are Effector_primers_general_results.tsv and
    Effector_primers_Nested_MFEprimer_results_assay_n_ingroup.tsv.
    """
    input_files = list(Path(input_directory).glob("*" + INPUT_EXTENSION))
    necessary_files = [file for file in input_files if "general_results" in file.stem or
                       ("Nested_MFEprimer" in file.stem and file.stem.endswith("outgroup"))]
    dataframes = {file.stem: pd.read_csv(file, sep="\t") for file in necessary_files}
    return dataframes


def remove_aspecific_ingroup_assays(assays_dictionary: Dict[str, Any]) -> Dict[str, Any]:
    """
    Loop over the assays and discard assays that do not have a 100% ingroup specificity.
    :param assays_dictionary: Dictionary containing assays to test for multiplex possibilities.
    :return: Dictionary with assays that have an ingroup specificity of 100%.
    """
    assays_dictionary_optimal_ingroup_specificity = {}
    for assay in assays_dictionary:
        if assays_dictionary[assay]["Great primers ingroup"] == OPTIMAL_SPECIFICITY:
            assays_dictionary_optimal_ingroup_specificity[assay] = assays_dictionary[assay]
    return assays_dictionary_optimal_ingroup_specificity


def get_assays_dictionary(input_dataframes: Dict[str, pd.DataFrame]) -> Dict[str, Any]:
    """
    Compile a dictionary for each assay storing information necessary to assess multiplex possibilities.
    :param input_dataframes: Dictionary of dataframes as input for the script among which are Effector_primers_general_results.tsv and
    Effector_primers_Nested_MFEprimer_results_assay_n_ingroup.tsv.
    :return: Dictionary containing assays with a 100% specificity for the ingroup.
    """
    assays_dictionary = {}
    # We make a dictionary for just the outgroup MFEresults.
    mfe_outgroup_dataframes = {key: input_dataframes[key] for index, key in enumerate(input_dataframes) if "MFE" in key}
    for index, row in input_dataframes["Effector_primers_general_results"].iterrows():
        genome_names = list(mfe_outgroup_dataframes[f"Effector_primers_Nested_MFEprimer_results_assay_{index + 1}_outgroup"]["Genome names"])
        off_targets_outgroup = list(mfe_outgroup_dataframes[f"Effector_primers_Nested_MFEprimer_results_assay_{index + 1}_outgroup"]["Number of qPCR detectable amplicons outgroup"])
        off_targets_outgroup_dict = dict(zip(genome_names, off_targets_outgroup))
        assays_dictionary[f"Assay_{index + 1}"] = {
            "Great primers ingroup": row["Great primers ingroup"],
            "Great primers outgroup": row["Great primers outgroup"],
            "Outgroup off target": off_targets_outgroup_dict,
            "Forward primer sequence": row["Forward primer sequence"],
            "Reverse primer sequence": row["Reverse primer sequence"],
            "Probe sequence": row["Probe sequence"]
        }

    assays_dictionary = remove_aspecific_ingroup_assays(assays_dictionary)

    if len(assays_dictionary) == 0:
        print(f"{Fore.BLUE}No assays are present with a 100% ingroup specificity.")

    return assays_dictionary


def multiplex_assays(assays_dictionary: Dict[str, Any]) -> Dict[str, dict]:
    """
    Compute a dictionary for potential multiplex assays.
    :param assays_dictionary: Dictionary containing assays with a 100% specificity for the ingroup.
    :return: Dictionary for multiplex assays with nested dictionaries for the individual assay and a nested dictionary
    for the outgroup off-targets combined per genome.
    """
    multiplex_assays_dict = {}
    multiplex_combinations = list(combinations(assays_dictionary, r=2))
    for combination in multiplex_combinations:
        combined_outgroup_off = {}
        for key, value in assays_dictionary[combination[0]]["Outgroup off target"].items():
            combined_outgroup_off[key] = assays_dictionary[combination[0]]["Outgroup off target"][key] + \
                                         assays_dictionary[combination[1]]["Outgroup off target"][key]
        multiplex_assays_dict[".".join(combination)] = {
            "assay 1": assays_dictionary[combination[0]],
            "assay 2": assays_dictionary[combination[1]],
            "combined_outgroup_off": combined_outgroup_off
        }
    return multiplex_assays_dict


def search_for_promising_mutliplex_assays(multiplex_assays_dict: Dict[str, dict]) -> dict:
    """
    Filter for promising multiplex assays. In these assays there are a maximum of 1 predicted amplicon per genome.
    :param multiplex_assays_dict: Dictionary for multiplex assays with nested dictionaries for the individual assay and
    a nested dictionary for the outgroup off-targets combined per genome.
    :return: Dictionary with multiplex assays that have not more than one predicted amplicon per outgroup genome.
    """
    promising_multiplex_assays_dict = {}
    for multiplex_assay in multiplex_assays_dict:
        combined_outgroup_off_unsuitable = {}
        for key, value in multiplex_assays_dict[multiplex_assay]["combined_outgroup_off"].items():
            if value >= MAXIMUM_AMPLICONS_MULTIPLEX:
                combined_outgroup_off_unsuitable[key] = value
        multiplex_assays_dict[multiplex_assay]["combined_outgroup_off_unsuitable"] = combined_outgroup_off_unsuitable
        if len(multiplex_assays_dict[multiplex_assay]["combined_outgroup_off_unsuitable"]) == 0:
            promising_multiplex_assays_dict[multiplex_assay] = multiplex_assays_dict[multiplex_assay]
    if len(promising_multiplex_assays_dict) == 0:
        print(f"{Fore.BLUE}No multiplex combinations were found with "
              f"0 or 1 predicted amplicons for each outgroup genome.")
    else:
        print(f"{Fore.BLUE}There are {len(promising_multiplex_assays_dict)} promising multiplex assays.")
    return promising_multiplex_assays_dict


def color_bool(val: Any) -> str:
    """
    Find booleans in a dataframe and color them according to the value.
    :param val: One value from the dataframe.
    :return: The color of the text for that particular cell.
    """
    if isinstance(val, bool):
        color = '#00ba38' if val else '#fc746c'
        return 'color: white; background-color: %s' % color


def color_amplicons(val: Any) -> str:
    """
    Find predicted amplicons in a genome and color them red.
    :param val: One value from the dataframe.
    :return: The color of the text for that particular cell.
    """
    if isinstance(val, int):
        color = '#00ba38' if val == 0 or val == 1 else '#fc746c'
        return 'color: white; background-color: %s' % color


def format_df(df: pd.DataFrame, title: str):
    s = df.style.format(formatter={
        "Promising multiplex combination": str
    })

    cell_hover = {  # for row hover use <tr> instead of <td>
        'selector': 'td:hover',
        'props': [('background-color', '#cbb600')]
    }
    index_names = {
        'selector': '.index_name',
        'props': 'font-style: italic; color: darkgrey; font-weight:normal;'
    }
    headers = {
        'selector': 'th:not(.index_name)',
        'props': 'background-color: #a14115; color: #cbb600;'
    }
    caption = {
        'selector': 'caption',
        'props': [
            ('color', '#cbb600'),
            ('font-size', '40px'),
            ("text-align", "left")]
    }

    border = {"border": "1.3px solid #a14115"}

    caption_text = f'{title}<br><span style="color:#a14115; font-size:20px">Table that shows which assays are ' \
                   f'predicted to work in multiplex. Here, we take only assays with a 100% ingroup specificity. ' \
                   f'We search for assays that only have zero or one off-target amplicons in all outgroup genomes. ' \
                   f'If so, the "Promising multiplex combination" column will be True.</span>'

    s.set_table_styles([cell_hover, index_names, headers, caption])
    s.set_caption(caption_text)
    s.set_properties(**border)
    s.applymap(color_amplicons)
    s.applymap(color_bool)

    return s


def compute_dataframe(multiplex_assays_dict, promising_multiplex_assays_dict,
                      output_path: Path, label_dict: Dict[str, str] = ""):
    """
    Compute a dataframe telling whether a multiplex assay is promising in silico. In addition, provide columns for each
    outgroup genome telling how many off-target amplicons are present.
    :param multiplex_assays_dict: Dictionary for multiplex assays with nested dictionaries for the individual assay and
    a nested dictionary for the outgroup off-targets combined per genome.
    :param promising_multiplex_assays_dict: Dictionary with multiplex assays that have not more than one predicted
    amplicon per outgroup genome.
    :param label_dict: Dictionary with GCF accessions as key and organism names as value.
    :param output_path: Relative path of output directory.
    """
    keys_multiplex_assay = list(multiplex_assays_dict.keys())

    multiplex_df_input = defaultdict(list)
    assay_names = [assay.split(".") for assay in keys_multiplex_assay]
    multiplex_df_input["First assay"], multiplex_df_input["Second assay"] = zip(*assay_names)
    multiplex_df_input["Promising multiplex combination"] = [key in list(promising_multiplex_assays_dict.keys())
                                                             for key in keys_multiplex_assay]
    for multiplex_assay in multiplex_assays_dict:
        for key, value in multiplex_assays_dict[multiplex_assay]["combined_outgroup_off"].items():
            if label_dict:
                keys_labels = list(label_dict.keys())
                matching_keys_labels = [key in label for label in keys_labels]
                matching_key_index = [index for index, x in enumerate(matching_keys_labels) if x]
                if len(matching_key_index) == 1:
                    organism_name = label_dict.get(keys_labels[int(matching_key_index[0])])
                    key = f"{organism_name} ({key})"
            multiplex_df_input[key].append(value)

    multiplex_df = pd.DataFrame(multiplex_df_input)
    multiplex_df.index += 1
    file_name = output_path / TSV_FILE_NAME
    with open(file_name, "w") as tsv:
        # noinspection PyTypeChecker
        multiplex_df.to_csv(tsv, sep="\t")

    formatted_df = format_df(multiplex_df, "Multiplex")
    file_name = output_path / HTML_FILE_NAME
    with open(file_name, "w") as html:
        html.write(formatted_df.to_html())
    soup = deal_with_large_tables(file_name)
    with open(file_name, "w") as html:
        html.write(str(soup.prettify()))


def main():
    args = parse_args()
    input_dataframes = get_necessary_dataframes(args.input_dir)
    assays_dictionary = get_assays_dictionary(input_dataframes)
    multiplex_assays_dict = multiplex_assays(assays_dictionary)
    promising_multiplex_assays_dict = search_for_promising_mutliplex_assays(multiplex_assays_dict)
    if args.labels.is_file():
        with open(args.labels) as js:
            label_dict = json.load(js)
        compute_dataframe(multiplex_assays_dict, promising_multiplex_assays_dict, args.output, label_dict=label_dict)
    else:
        compute_dataframe(multiplex_assays_dict, promising_multiplex_assays_dict, args.output)


if __name__ == '__main__':
    main()